# 1. 데이터 타입의 종류

|     | data types                    | 데이터                                                                 | 성질   | 할당 시 특징 | 복사 시                                                     |
| --- | ----------------------------- | ---------------------------------------------------------------------- | ------ | ------------ | ----------------------------------------------------------- |
|     | primitive type(기본형/원시형) | Number, String, Boolean,<br>null/undefined, Symbol                     | 불변성 | 복제됨       | 값이 담긴 주솟값을 복사                                     |
|     | reference type(참조형)        | Object{ Array, Function, Data, <br>RegExp, Mapp/WeakMap, Set/WeakSet } | 가변성 | 참조됨       | 값이 담긴 주솟값으로 이루어진 묶음을 가리키는 주소값을 복사 |

# 2. 데이터 타입 배경지식: 메모리와 데이터, 식별자와 변수

### 메모리

- 메모리는 unique idntifier로 식별 가능 및 위치 확인이 가능한 bit로 이루어져 있다.
- 1bit 단위로 검색 하는 건 매우 비효율적이므로 8bit씩 묶자! 8bit = 1 byte(2^8 = 256개의 값 표시 가능)
- 8 bit단위로 묶인 byte역시 시작하는 bit의 식별자로 위치 파악 가능하고, 메모리는 byte단위로 주소를 가진다. 이것이 바로 memory address

## 언어별 데이터 타입과 메모리

- static type 언어는 각 데이터 타입별로 할당할 메모리 영역을 정해두고 필요시 사용자(programmer)가 타입을 형변환하게 함
- javascript는 메모리 공간을 넉넉하게 할당: 정수/부동소수점 구분 않고 8byte를 할당한다.

## 변수와 식별자의 구분

때때로 혼용해서 쓰지만 구분되는 것.

- 변수: 변할 수 있는 무언(데이터)
- 식별자: 데이터를 식별하는 데 사용하는 이름(=변수명)

# 3. 변수 선언과 데이터 할당

## 변수 선언시 벌어지는 일

```javascript
var a;
```

1. cpu(컴퓨터)가 memory에 비어있는 공간 하나를 확보 (memory address: 1002)
2. 확보한 공간에 식별자를 a로 지정(=해당 공간에 이름 지정) → 앞으로 이 이름(a)을 가진 주소를 검색하여 데이터를 반환함

## 데이터 할당 시 벌어지는 일

```javascript
var a = "abc";
a = "abcdef";
```

> 할당한 문자열(abc)를 a의 주소(1002)에 **직접 저장하지 않는다!**

3. 다른 메모리 공간(ma: 5004)에 'adc'를 저장
4. 식별자 a를 가진 주소를 검색
5. 'abc'를 저장한 주소를 식별자 a의 공간(1002)에 저장한다. (=> c의 포인터와 같다)

## 재할당시 벌어지는 일

6. 'abcdef'를 또다른 메모리 공간(ma: 7004)에 저장
7. 식별자 a의 공간(1002)에 'abcdef'를 저장한 주소를 저장(연결)한다.

> 연결이 해제된 기존 데이터('abc', ma: 5004)는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬랙터의 수거 대상이 된다.

### 왜?

메모리를 효율적으로 관리하고, 데이터 변환을 자유롭게 하고자.

if: 직접 식별자 'a'의 위치에 데이터를 넣는다면 확보한 공간을 데이터 크기에 맞게 변환해야 한다. 그렇다면 기존에 저장된 데이터들을 이동하고, 이 이동시킨 주소를 각 식별자와 연결 시켜주어야 하며, 이는 컴퓨터의 연산을 늘린다.(불필요한 cost가 발생) 따라서 직접 할당 및 직접 수정이 아니라 다른 공간에 데이터를 넣고 해당 데이터의 주소를 식별자에 연결시켜주는것으로 할당 및 재할당한다.

# 4. 기본형 데이터와 참조형 데이터

### 변경 가능성의 대상

- 변수/상수의 구분: 한번 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당할 수 있는지에 대한 이야기(ex: 위의 예시에서 식별자 a의 공간(1002)에 다른 값을 가진 주소를 넣어줄 수 있는지 없는지)
- 불변성 여부의 구분: 진짜 데이터가 할당되는 영역(ex: 'abc'와 'abcdef')의 이야기

## 불변값 (기본형/원시형)

```javascript
var a = 5;
var b = 5;
a = 7;
```

1. 식별자 a의 공간을 할당
2. 숫자 5가 있는 메모리 공간의 유무 탐색
3. (없을 때 새로 5를 할당한 공간 생성 / 있을 때 5의 주소를 가져와서) 식별자 a의 주소 공간에 해당 주소를 저장
4. 식별자 b의 공간을 할당
5. 숫자 5가 있는 메모리 공간의 유무 탐색
6. (이미 존재하는) 숫자 5가 있는 주소를 가져와(재활용) 식별자 b의 주소 공간에 해당 주소를 저장
7. 숫자 7이 있는 메모리 공간의 유무 탐색
8. (없을 때 - 있을 때) 식별자 a의 주소 공간에 7이 있는 주소를 저장 (5의 주소는 사라짐)

> 5와 7 모두 다른 값으로 변경할 수 없다! 단지 값이 있는 주소를 갈아끼우는 것 뿐이다. (이런 점에서 불변하다고 한다)

해당되는 데이터 : Number, String, Boolean, null/undefined, Symbol

## 가변값 (참조형)

```javascript
var obj1 = {
  a: 1,
  b: "abc",
};
```

1. 식별자 obj1를 위한 공간(ma: 1004) 활당
2. obj1가 **여러 property를 가진 데이터 그룹** 이므로 *이 그룹 내부의 여러 property들을 저장할 공간(ma: 7004, 7005...)*을 확보, 해당 공간(해당 영역의 주소)을 저장하는 공간을 확보 및 저장(ma: 5004)
3. 2에서 확보한 각각의 property a,b의 데이터를 저장할 공간(7004, 7005)에 property 이름을 지정
4. 메모리 영역에서 1을 검색, (존재시 해당 주소를/없을시 임의의 주소공간에 1을 저장하고 해당 주소를) **해당 property의 공간**(7004)에 저장
5. 메모리 영역에서 'abc'를 검색, (존재시 해당 주소를/없을시 임의의 주소공간에 'abc'을 저장하고 해당 주소를) **해당 property의 공간**(7005)에 저장

- [2] 에서의 *객체의 property를 저장하기 위한 메모리 공간*은 필요한 시점에 동적으로 할당 된다.
- 4와 5 단계(property의 데이터) 기존의 메모리 공간을 활용하며 불변하지만, 2는 다른 값으로 바뀔 수 있다. 즉, **변수에는 다른 값을 얼마든지 대입할 수 있다.** (따라서 불변하지 않다(=가변값)이다) c의 2차원 포인터와 같은 원리인 듯 싶다.

### 중첩된 참조형 데이터(객체)의 property 할당

```javascript
var obj2 = {
  a: 3,
  arr: [3, 4, 5],
};
```

1. obj2을 위한 공간 확보 (@1002)
2. obj2에 할당받은 데이터를 임의의 데이터 영역(@5001)에 저장하려는데, obj2이 할당받은 건 여러 property를 가진 객체이므로 해당 property들을 위한 공간 확보(@7103~) 및 확보한 공간 주소들을 (1)그 데이터 영역에 저장하고(5001/-/@7103~) (2) 해당 임의의 데이터 영역 주소를 obj2의 공간에 저장(1002/obj2/@5001)
3. 2에서 확보한 공간 중 하나에 a라는 식별자를, 다른 공간 하나에 arr를 붙임 (7103/a/-)(7104/arr/-)
4. 메모리에서 1이 있는 주소를 탐색, (있을 시 그대로 가져온, 기존에 3이 있는 메모리 주소를/ 없을 시 새로 3을 할당한 메모리 주소(5002/-/3)를) 3에서 a식별자를 이름붙인 공간에 저장 (7103/a/5002)
5. arr에 할당받은 데이터를 임의의 데이터 영역(@5003)에, arr가 여러 데이터가 있는 데이터 그룹이므로 그룹 내부의 property를 저장하기 위한 공간 확보(@8104 ~) 및 확보한 공간 주소들을 3에서 arr식별자로 이름붙인 공간에 저장(7104/arr/@5003), (@5003/-/@8104~)
6. 배열 요소가 3개이므로 3개의 공간을 확보하고 각각 index를 식별자로 부여(8104/0/-)(8105/1/-)(8106/2/-)
7. 숫자 3을 검색 (있을 시(5002) /없을 시) 주소를 index 0의 공간에 저장(8104/0/5002)
8. 숫자 4를 검색 (있을 시 /없을 시(5004)) 주소를 index 1의 공간에 저장(8105/1/5004)
9. 숫자 5를 검색 (있을 시 /없을 시(5005)) 주소를 index 2의 공간에 저장(8106/2/5005)

### `obj2.arr[1]` 검색시 메모리의 검색 과정

1. obj2라는 식별자를 가진 주소를 탐색 (@1002)
2. obj2라는 식별자(변수명)의 값이 주소이므로 해당 주소로 이동(@5001)
3. obj2의 값(=obj 객체의 property(의 주소)들을 담고 있는 주소)이 주소이므로 주소로 이동{ (@7103~) }
4. a와 arr의 각각의 주소를 담고 있는 주소로 이동(@7103/@7104(\*))->(7104/arr/@5003)
5. arr의 식별자를 가진 공간의 값에 담긴 주소를 탐색 및 arr(의 property들(의 주소)을 담고 있는) 주소로 이동( (@8104~) )
6. 6에 담겨있는 주소 중 식별자 1을 가진 주소를 탐색(@8105)
7. 식별자 1(=index 1)을 가진 주소로 이동(@5004)
8. 8에서 이동한 주소의 값이 숫자형 데이터이므로 4를 반환

### `obj2.arr = 'abc`를 재할당한다면?

1. 다른 주소(5006)에 'abc'를 저장
2. obj2.arr의 주소(7104/arr/@5003)에 1의 주소를 저장=>(7104/arr/@5006)

자신의 주소를 참조하는 변수의 개수를 새는 참조 카운트가 있는데, 어떤 변수가 더이상 자신의 주소를 참조하지 않을 때(재할당, 2번의 상황이 발생시) 1에서 0이 된다.

> 참조 카운터가 0인 메모리 주소는 가비지 컬렉터(garbage collector, GC)의 수거 대상이 되며, GC는 런타임 환경에 따라 특정 시점/메모리 사용량이 거의 다 찼을 때(임박할 때마다) 자동으로 수거 대상을 수거(collecting)한다. 수거된 메모리는 다시 할당 가능한 빈 공간이 된다!

2번의 상황이 발생했을 때 어떻게 값이 사라질까?

1. @5003(@5003/-/@8104~)의 참조 카운터가 0이 됨
2. 언젠가 @5003의 값이 사라짐
3. 2 발생시 @8104~에 있는 데이터들의 참조 카운터가 연쇄적으로 0이 됨
4. 언젠가 @8104~의 값들도 사라짐

## 변수 복사 비교

```javascript
var a = 10; // (1001/a/@5001)
var b = a; // (1002/b/@5001)

var obj1 = { c: 10, d: "ddd" }; // (1003/obj1/@5002)
var obj2 = obj1; // (1004/obj2/@5002)

// (5002/-/@7103~)
// (7013/c/@5001), (7014/d/@5003)
```

변수를 복사할 때 기본형/참조형 모두 원본 변수의 주소를 넣어주는 것이 아닌, 원본 변수의 데이터를 담아둔 주소를 넣어준다.(= 같은 주소를 바라보게 되는 점에서 동일하다) 즉, a와 b의 경우 둘 다 숫자 10이 담긴 메모리 주소를 값으로 갖게 되며, obj1과 obj2의 경우 obj1의 객체를 담고 있는 메모리 주소를 obj2의 식별자가 붙은 메모리 공간이 갖게 된다.

# 변수 복사 이후 값을 변경한다면?

## 객체 내부의 property의 값을 변경할 때

```javascript
var a = 10; // (1001/a/@5001)
var b = a; // (1002/b/@5001)

var obj1 = { c: 10, d: "ddd" }; // (1003/obj1/@5002)
var obj2 = obj1; // (1004/obj2/@5002)

// (5002/-/@7103~)
// (7013/c/@5001), (7014/d/@5003)

/////////////////////

b = 15;

//(5004/-/15)
//(1002/b/@5001) ==> (1002/b/@5004) [b에 담긴 주소가 변경됨]

obj2.c = 20;
//(5005/-/20)
//(7013/c/@5001) ==> (7013/c/@5005)

// (1004/obj2/@5002) = (1004/obj2/@5002) [obj2에 담긴 주소는 변경되지 않았다]
// (5002/-/@7103~) (이것도 변경 안 됨)

a !== b;
obj1 == obj2;
```

변수 a와 변수 b는 서로 다른 주소를 바라보게 되었으나 obj1과 obj2는 서로 같은 객체를 바라본다.

|                        | 기본형(원시형)          | 참조형                           |
| ---------------------- | ----------------------- | -------------------------------- |
| 원본과 복사본은        | 서로 다른 주소를 바라봄 | 서로 (여전히) 같은 객체를 바라봄 |
| 주솟값을 복사하는 과정 | 1번                     | 한 단계를 더 거침                |

### 객체 자체를 변경할 때

만약 객체 자체를 변경한다면 값이 달라진다.

```javascript
var a = 10; // (1001/a/@5001)
var b = a; // (1002/b/@5001)

var obj1 = { c: 10, d: "ddd" }; // (1003/obj1/@5002)
var obj2 = obj1; // (1004/obj2/@5002)

b = 15;
// 5006/-/@8204~
// 5006은 ({c: 20, d:'ddd'} 라는 객체를 새로 할당받은 주소)

obj2 = { c: 20, d: "ddd" }; //(1004/obj2/@5002) => (1004/obj2/@5006) [변경 됨]
```

> 참조형 데이터가 *가변값*이라고 할 때, 참조형 데이터 자체를 변경할 경우가 아닌 _내부의 property를 변경할 때에만_ 성립.

- 데이터 자체를 변경할 때(=새로운 데이터를 할당할 때) 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다.

# 5. 불변 객체(Immutable object)

Immutable object는 디자인패턴, 함수형 프로그래밍 등에서 모두 매우 중요한 기초가 되는 개념으로, 값으로 전달받은 객체에 변경을 가해도 원본 객체가 변하지 않아야 할 때와 같은 상황에서 필요하다.

## 불변 객체를 만드는 간단한 방법

객체는 참조형 데이터이고, 참조형 데이터는 내부의 property를 변경할 때 가변적이다. 그런데 만약 객체 내부의 property를 변경할 때 원본이 되는 객체의 값을 보존해야 한다면 어떻게 해야할까? 데이터 자체를 변경할 때(=새로운 데이터를 할당할 때) 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않으므로, 내부 property를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당 / 자동으로 새로운 객체를 만드는 도구(라이브러리)를 사용한다면 객체도 불변성을 확보할 수 있다.

아래 코드의 경우는 객체를 새로 만들지 않은 채로 property를 변경했기 때문에 원본 객체 또한 값이 변경되었다.

```javascript
var user = {
    name = 'jn',
    genter = 'm'
};

var changeName (user, newName) {
    var newUser = user;
    newUser.name = newName;
    return newuser;
};

var user2 = changeName(user, 'j');

if(user!==user2) { console.log("유저 정보가 변경되었습니다");}

console.log(user.name, user2.name); // j, j
console.log(user == user2) //true
```

새로운 객체를 반환하게 변경

```javascript
var changeName (user, newName) {
    return {
        name: newName,
        gender: user.gender
    };
};

//...

console.log(user.name, user2.name); // jn, j
console.log(user == user2) //false
```

기존 객체의 property(gender)를 하드코딩하고 있다. 이럴 때 원본/대상 객체에 정보가 많을수록 입력해야 하는 수고가 늘어나므로, 대상 객체의 property 개수에 상관 없이 모든 property를 복사하는 함수를 만든다. (기존 정보를 복사해서 새로운 객체를 반환하는 함수로 얕은 복사이다.)

```javascript
var copyObject = function (target) {
  var result = {};

  for (var prop in target) {
    //for in 문법 사용
    result[prop] = target[prop];
  }

  return result;
};

var user2 = copyObject(user);
user2.name = "j";
```

이 함수의 문제점(참조)

1. prototype chaining의 모든 property를 복사함
2. getter/setter는 복사하지 않음
3. 얕은 복사만을 수행

user 객체 변경시 copyObject를 사용하도록 협업하는 개발자들과 합의/수행한단 전제 하에선 이제 user는 불변 객체가 된다. 그러나 더 확실하게 하기 위해선 시스템적으로 제약을 거는 게 안전하기에 immutable.js등의 _내장 객체가 아닌 라이브러리 자체에서 불변성을 지닌 별도의 데이터 타입과 메서드를 제공하는_ 라이브러리등이 등장하여 인기를 끌고 있다.

## 얕은 복사와 깊은 복사

| 얕은 복사                  | 깊은 복사                                  |
| -------------------------- | ------------------------------------------ |
| 바로 아래 단계의 값만 복사 | 내부의 모든 값을 하나하나 찾아서 전부 복사 |

**얕은 복사**는 중첩된 객체에서 참조형 데이터가 저장된 property를 복사할 때 그 주소값만 복사한다. 그렇다면? 해당 property에 대해서 원본과 사본 모두 동일한 주소를 바라보고 있고(동일 참조형 데이터 주소를 가리킴), 그 주소에서 값이 변경되면(가령 사본을 통해 해당 주소의 값을 변경하거나/원본을 통해 ...) 다른 측의 값도 바뀌게 된다.

따라서 어떤 객체를 객체 내부의 모든 값을 복사해서 완전히 복사해 새로운 데이터를 만들고자 한다면 객체의 property의 data 타입에 따라 복사 방법이 달라진다.

- 기본형(원시형) property: 그대로 복사한다
- 참조형 property : 그 내부의 property도 복사해야 한다.
  위 과정을 재귀적으로 수행해야 깊은 복사가 된다.

```javascript
var DeepcopyObject = function (target) {
  var result = {};

  if (typeof target == "object" && target != null) {
    for (var prop in target) {
      result[prop] = DeepcopyObject(target[prop]);
    }
  } else {
    result = target;
  }

  return result;
};
//원본과 사본이 서로 다른 객체를 참조하게 된다
```

`target != null` : `typeof`는 null 또한 'object'를 반환한다.

1. prototype chaining의 모든 property를 복사함
   - `hasOwnProperty`메서드로 prototype chaining을 통해 상속된 property를 복사하지 않게끔 할 수도 있다.
2. getter/setter는 복사하지 않음
   - (ES5의)getter/setter복사 방법
     - ES6: `Object.getOwnPropertyDescriptor`
     - ES2017: `Object.getOwnProeprtyDescriptors`
3. 얕은 복사만을 수행
   - 재귀적으로 **내부의 property** 또한 복사하기
   - 객체를 **JSON**문법으로 표현된 문자열로 전환 -> 다시 JSON객체로 바꾸기
     - methond(함수) / (숨겨진 property인) `__proto__`나 getter/setter 등과 같은 JSON으로 변경 불가능한 property들은 모두 무시함. 따라서 `httpRequest`로 받은 데이터를 저장한 객체를 복사할 때와 같은 순수 정보 핸들링 시 사용하는 게 좋다!

```javascript
var copyObjectViaJson = function (target) {
  return JSON.parse(JSON.stringify(target));
};
```

# 6. undefined / null

`undefined`

- 사용자가 명시적으로 지정
- 값이 존재하지 않을 때 js엔진이 자동으로 부여

## JS engine이 undefined를 반환하는 경우

(1) 값을 대입하지 않은 변수(ex.선언만 한 경우) 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
(2) 객체 내부의 존재하지 않은 property에 접근할 때
(3) return문이 없거나 호출되지 않은 함수의 실행 결과

### [undefined 관련] 값을 대입하지 않은 경우:: 배열일 때

```javascript
var arr1;
arr1.length(3);
console.log(arr1); //[empty x 3]

var arr2 = new Array(3);
console.log(arr2); //[empty x 3]
```

- 배열에 3개의 빈 요소를 확보했으나, 확보한 요소는 어떤 값도 할당되어 있지 않음.
- 배열 인스턴스를 생성한 경우도 같음.

```javascript
//리터럴 방식으로 선언, 요소에 부여
var arr3 = [undefined, undefined, undefined];
console.log(arr3); //[undefined, undefined, undefined]
```

> **비어있는 요소(empty)** 와 **undefined를 할당한 요소** 는 결과가 다르다! (비어있는 요소는 많은 배열 메서드 순회 시 대상에서 제외됨)

## [undefined 관련] 빈 요소와 배열의 순회

> 배열의 각 요소를 순회하는 메서드들: `foreach`, `map`, `filter`, `reduce`

```javascript
var arr1 = [undefined, 1]; //사용자가 직접 undefined를 할당
var arr2 = [];
arr2[1] = 1;

/* Foreach */
arr1.foreach(function (v, i) {
  console.log(v, i);
});
// undefined 0
// 1, 1
arr2.foreach(function (v, i) {
  console.log(v, i);
});
// 1, 1

/* map */
arr1.map(function (v, i) {
  return v + 1;
});
// [NaN, 2]
arr2.map(function (v, i) {
  return v + 1;
});
// [emtpy, 2]

/* filter */
arr1.filter(function (v) {
  return !v;
});
// undefined
arr2.filter(function (v) {
  return !v;
});
// []

/* reduce */
arr1.reduce(function (p, c, i) {
  return p + c + i;
}, "");
// undefined011
arr2.reduce(function (p, c, i) {
  return p + c + i;
}, "");
// 11

/* 
arr1(사용자가 직접 undefined를 할당함) => 배열의 모든 요소를 순회
arr2(사용자가 직접 할당 x, 엔진이 자체적으로 할당?) => 비어있는 요소는 처리하지 않음
*/
```

### [undefined 관련] 왜?

(배열이지만 객체처럼) 존재하지 않는 property에 대해서는 순회가 불가능하다. 배열도 객체처럼 특정 index에 값을 저장할 때 비로소 공간 확보 및 index를 이름으로 지정, 데이터 주소값을 저장한다(vm에서 정말 필요할 때 메모리를 할당하는 demand paging이 생각 난다.) 따라서 값이 지정되지 않은 index는 아직 존재하지 않은 property와 같다.
length(3)을 선언한다고(length property)의 개수만큼 빈 공간 확보 후 인덱스를 식별자로 지정하는 것이 아니다!

| 사용자가 명시적으로 할당한 `undefined`           | 비어있는 요소에 접근하려 할 때 반환되는 `undefined`      |
| ------------------------------------------------ | -------------------------------------------------------- |
| `undefined`는 값이기 때문에 하나의 값으로 동작함 | 실존하지 않은, 값이 없음을 나타내기 때문에 동작하지 않음 |
| property/배열의 요소가 고유값이 실존함           | property/배열의 key값(index)자체가 존재하지 않음         |
| 배열시 순회                                      | 배열시 순회 안 함                                        |

## `undefined`와 `var`, `let`, `const`

`var`는 undefined로 초기화되며 접근이 가능하다. 그러나 ES6 이후의 `let`, `const`는 undefined되지 않은 채로 초기화되며 실제 변수가 평가되기 전까진 접근 불가능하다
|`var` |`let`/`const`|
|- | -|
|environmentRecord가 인스턴스화될 때 생성되며 undefined로 초기화된다|environmentRecord가 인스턴스화될 때 생성되나 실제 변수가 평가되기 전까지 접근할 수 없다.|

## `null`

> Q `undefined`직접 명시적으로 할당하며 쓰면 쓰임새가 헷갈리는데 방법이 없을까? <br> A 비어있음을 명시적으로 표시하고 싶다면 `null`을 쓰는 것이 좋다.<br>이 경우 `undefined` = `값을 대입하지 않은 변수에 접근할 때 JS 엔진이 반환해주는 값`

### 유의해야 하는 bug

> `typeof null`은 `object`이다.

## `undefined` 와 `null`의 비교

| 연산자 종류        | 비교 결과        |
| ------------------ | ---------------- |
| 동등 연산자(`==`)  | 서로 같다고 판단 |
| 일치 연산자(`===`) | 정확 판별 가능   |

# 읽을 포스트

[c와 javascript의 비교](https://post.naver.com/viewer/postView.naver?volumeNo=17988573&memberNo=21815&navigationType=push)

[자바스크립트 참조에 관한 시각적 가이드 [aka 자바스크립트 포인터]](https://itchallenger.tistory.com/725)
